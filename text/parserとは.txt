パーサーとは。
何だろう。
抽象化....
まずオブジェクト表記で書かれていて、そこから...
Unitクラスは
action配列とactionIndexという
action配列の何番目の内容を実行しているかをあらわす整数
これが最低備わっていること
さらにCounterが無いとね
ここまでテンプレート
waitが鍵
おそらく非同期処理みたいなことがしたい？

個別のパーサー
コマンドを分かりやすくエッセンスだけ抜き出したり
個別に解釈したり
それの内容がUnitによりけり
というのをやりたいようです？？

例
{
  x:0.5, y:0.3, shotDirection:90, collisionFlag:ENEMY,
  action:{
    main:[{catch:"a"}, {shotDistance:["set", 50]},
          {shotAction:"scatter"}, {radial:{count:2}}, {wait:120},
          {shotAction:"scatterInv"}, {radial:{count:2}}, {wait:120},
          {loop:INF, back:"a"}],
    scatter:[{short:"scatter", bearing:1.5, dirDiff:15}],
    scatterInv:[{short:"scatter", bearing:-1.5, dirDiff:-15}],
    trap:[{wait:60}, {speed:["set", 3, 120]}]
  },
  short:{
    scatter:[{move:"circular", bearing:"$bearing", radiusDiff:1}, {bind:true},
             {wait:30}, {shotAction:"trap"}, {shotSpeed:["set", 0.0001]}, {catch:"b"},
             {shotDirection:["fromParent", "$dirDiff"]}, {fire:""}, {wait:4}, {loop:INF, back:"b"}]
  }
}

んー...
1.グローバル表記
ここにあるプロパティはUnitの初期設定のためのものですね
2.action情報
actionプロパティにはmainとその他のプロパティがmainを一番最初として並んでいますね
mainが一番最初
依存関係的にこれが一番最初でそれ以降は前の配列に情報として使われる形なのですね
それを展開するメソッドありますね
配列内の{}たちが最終的にコマンドになるわけですけどそれをコマンドにする処理は別に用意されていて
さらにコマンドを解釈してUnitに命令するパートも別に用意されている
そしてそもそもこのままでは{}の配列になっていない場合にそれを実現するための処理が必要なわけですけれども
それを実行するパートがあるわけですね
3.short情報
ところでそれを実行するためにまずもってこのshortで短く書く...というのも同じ内容を複数回書くのが冗長な場合があって
その場合にまとめて同じ内容を書くことができる。それがshort.

パースの手順
まず。。。ん？？
shotActionですね。
出力したクローンに何をさせるかを指定できるのでそれが配列として

無ければ無しでOKです

うん...
命令には自分のクローンをどんなふうにするかを具体的に指定するようなのもあるわけで割と自由度が
高い！！！！

ので、どうしたもんか、エッセンスはどこだ、そんな話になっております。
他のことができないくらい
夢中になってしまう...いけない...

あ、そうだ、main以外のプロパティは全部shotActionで使うんだっけ。
つまりshotに設定するactionの内容を決定しないといけないんだよな
それとは別に発射したUnitにいろいろ設定する際の内容もいじらないといけないし大変
クローン作らないならいいんだけど
結局lineとかradialは何をしてるかというとあそこにも{}の配列が入るんだけど
その略記法ね。実質shortと基本的にやってることは同じだけど
actionに何か入れられる
これは発射する側のactionとして用いるもの（ややこしい）
要するにradialのlineとかnwayのradialとかそういうことがしたいわけね。

これを抽象化するのは難しいので切る

patternSeed

seed={global:{いろいろ}, action:{main:[], ほかの1:[], ほかの2:[], ...}, short:{いろいろ}}

って感じ
parseにおいて
まずglobalの処遇について
ここの内容を元にUnitとしてどんなものを作るかが決まる感じで、略記法を採用した場合はパース規則を設ける
基本的には
あー、初期設定、だわね...actionで変えるかもだけどとりあえず初期設定です。
で、...

難しい

actionの展開
まずshortを使ってactionのところの配列を全部バラす
次にそれぞれについてループの文字列を実数値にしたりとか、lineやradialの内容をばらしたりする
さらに
この時点ではshotActionのvalueが単なる文字列なので、そこをactionで置き換えるために、
さらなる処理を要する。これで完成です。

まだ終わらないけどね。
その際に単なる{}だったものがUnitへの命令に変化しますね。
そしてその命令をいかにして実行するのか、それについては自由度が高すぎて....
それもきちんと枠組みを整えて成立することなのでしょう。
実行の仕方を関数で定義する。そこへいくと
それも用意するわけだがそれ関数としてどうなんだろ、勝手に決めれるようにしたいね・

マルチスレッド
actionの上位構造
たとえば単独action1個だけっていうのがデフォルト
他には
いくつかactionを持っていてそれらの組み合わせが変わるとかんーとえーと
複数のactionを同時実行して
たとえばあるactionは常に実行し続けて
複数のactionを同時に実行し続けるでもいい？
複数分岐！どれかひとつ選んでそれが実行され終わったら特定のポイントに戻ってみたいななんかそんな感じ

今はいいです

共通の命令
waitとかcatchとかloop,backとかは共通でいい
setとか（パラメータに値を決めるだけ）
setでもたとえば数を決めてある値からある値まで変化、
ある範囲の値をランダムに取得、
ある値にある値を足す、
ランダムでどれかを取得、
もしくは掛け算、バリエーションは豊富。割と汎用性高いと思う

さてとまずは
思ったけどglobalってただのJSON？
ってことは割と自由度高いわけね
UnitのinitializeにそのJSONに対してどういう処理をするかを
んー...
実際そうなってるからね...
はい。

class Unit{constructor(){this.action～～; this.actionIndex～～;this.counter～～;}}
class LoopCounter{}
これだけで。
function parsePatternSeed(seed){
  let ptn = {};
  seed.globalを使ってptnになんか設定してその情報はunitのinitializeで使う
  seed.shortの情報によりseed.actionの内容を加工する
  seed.actionの内容を整理してcommandにできる{}だけにする
  {}だけになったらそれらをcommandに変換する（主要なコマンドはデフォルトであるけど自由に追加できる）
  変換規則は自分で作る必要があるけどね
  ptn.actionに結果の配列が入る。おわり。
}
使い方
unitのexecuteでactionを実行していく
LoopCounterが活躍する
おわり

ループを使わない方法
ノードに

...

細かいactionたちをループで貼り合わせるイメージ

やめよ
また今度考える
